@startuml
title Diagrama de Clases: E-Commerce Mon Amour Studio\n(Refleja implementación real del monorepo – 22 entidades · 6 microservicios)

skinparam classAttributeIconSize 0
skinparam Shadowing false
skinparam defaultFontSize 11
skinparam packageStyle rectangle

' ══════════════════════════════════════════════════════════════
'  Infraestructura de Eventos (Kafka)
' ══════════════════════════════════════════════════════════════
package "Infraestructura Eventos (Kafka KRaft)" #TECHNOLOGY {
  class KafkaEventProducer {
    - bootstrap_servers: string
    - producer: AIOKafkaProducer
    + start(): void
    + stop(): void
    + publish(topic: str, key: str, value: dict): void
  }

  class KafkaEventConsumer {
    - bootstrap_servers: string
    - group_id: string
    - consumer: AIOKafkaConsumer
    - processed_ids: Set<string>
    + start(): void
    + stop(): void
    + consume(topics: list, handler: Callable): void
  }
}

' ══════════════════════════════════════════════════════════════
'  Microservicio Usuarios
' ══════════════════════════════════════════════════════════════
package "Microservicio Usuarios" #LightBlue {
  class Usuario <<Entity>> {
    - id: UUID
    - nombre: String(120)
    - email: String(255) «unique»
    - password_hash: Text
    - rol: String(30) = "cliente"
    - telefono: String(30)?
    - foto_url: String(500)?
    - created_at: DateTime(tz)
  }

  class Direccion <<Entity>> {
    - id: UUID
    - usuario_id: UUID «FK»
    - etiqueta: String(60) = "Casa"
    - linea1: String(255)
    - linea2: String(255)?
    - ciudad: String(120)
    - provincia: String(120)
    - codigo_postal: String(20)
    - pais: String(60) = "Ecuador"
    - es_principal: Boolean = false
    - created_at: DateTime(tz)
  }

  class MetodoPago <<Entity>> {
    - id: UUID
    - usuario_id: UUID «FK»
    - tipo: String(30) = "Visa"
    - ultimos_4: String(4)
    - titular: String(120)
    - expiracion: String(7)
    - es_principal: Boolean = false
    - created_at: DateTime(tz)
  }

  class Sesion <<Entity>> {
    - id: UUID
    - usuario_id: UUID «FK»
    - token: Text
    - expira: DateTime(tz)
    - created_at: DateTime(tz)
  }

  class UsuarioService <<Service>> {
    + register(db, data): Usuario
    + authenticate(db, email, password): TokenResponse
    + google_auth(db, token): TokenResponse
    + get_by_id(db, user_id): Usuario
    + update_profile(db, user_id, data): Usuario
    + change_password(db, user_id, data): void
    + upload_avatar(db, user_id, file): Usuario
    + list_users(db): list[Usuario]
    + update_role(db, user_id, role): Usuario
    + delete_user(db, user_id): void
  }

  class UsuarioRepository <<Repository>> {
    + create(db, usuario): Usuario
    + get_by_email(db, email): Usuario?
    + get_by_id(db, user_id): Usuario?
    + update(db, user_id, data): void
    + list_all(db): list[Usuario]
    + delete(db, user_id): void
  }

  class UsuariosController <<Controller>> {
    + POST /register
    + POST /login
    + POST /google-login
    + GET /me
    + PUT /me
    + PUT /me/password
    + POST /me/avatar
    + GET /
    + PUT /{user_id}/role
    + DELETE /{user_id}
  }
}

' ══════════════════════════════════════════════════════════════
'  Microservicio Inventario
' ══════════════════════════════════════════════════════════════
package "Microservicio Inventario" #LightGreen {
  class TipoProducto <<Entity>> {
    - id: UUID
    - nombre: String(120) «unique»
    - created_at: DateTime(tz)
  }

  class Garantia <<Entity>> {
    - id: UUID
    - nombre: String(120) «unique»
    - dias: Integer
    - created_at: DateTime(tz)
  }

  class Empaque <<Entity>> {
    - id: UUID
    - nombre: String(120) «unique»
    - created_at: DateTime(tz)
  }

  class Descuento <<Entity>> {
    - id: UUID
    - nombre: String(120) «unique»
    - porcentaje: Float (0-100)
    - created_at: DateTime(tz)
  }

  class Producto <<Entity>> {
    - id: UUID
    - sku: String(80) «unique»
    - nombre: String(255)
    - descripcion: Text?
    - precio: Numeric(10,2)
    - moneda: String(10) = "USD"
    - disponibilidad: Integer = 0
    - max_por_pedido: Integer = 1
    - imagen_url: String(500)?
    - imagen_preview_url: String(500)?
    - envio_gratis_umbral: Numeric(10,2)?
    - calificacion_promedio: Float = 0.0
    - total_resenas: Integer = 0
    - tipo_producto_id: UUID? «FK»
    - garantia_id: UUID? «FK»
    - empaque_id: UUID? «FK»
    - descuento_id: UUID? «FK»
    - created_at: DateTime(tz)
    - updated_at: DateTime(tz)
  }

  class Resena <<Entity>> {
    - id: UUID
    - producto_id: UUID «FK»
    - usuario_id: UUID
    - usuario_nombre: String(255)
    - calificacion: Integer (1-5)
    - comentario: Text?
    - created_at: DateTime(tz)
  }

  class Talla <<Entity>> {
    - id: UUID
    - producto_id: UUID «FK»
    - nombre: String(20)
    - ancho_cm: Float
    - alto_cm: Float
    - precio_adicional: Numeric(10,2) = 0
  }

  class Favorito <<Entity>> {
    - id: UUID
    - usuario_id: UUID
    - producto_id: UUID «FK»
    - created_at: DateTime(tz)
    .. unique(usuario_id, producto_id) ..
  }

  class ReglaDisponibilidad <<Entity>> {
    - id: UUID
    - producto_id: UUID «FK»
    - tipo: String(50)
    - limite_por_pedido: Integer = 1
    - ventana_inicio: DateTime(tz)?
    - ventana_fin: DateTime(tz)?
  }

  class InventarioService <<Service>> {
    + list_products(db, filters): list[Producto]
    + get_product(db, id): Producto
    + create_product(db, data): Producto
    + update_product(db, id, data): Producto
    + delete_product(db, id): void
    + reserve_stock(db, id, cant, pedido_id): void
    + release_stock(db, id, cant, pedido_id): void
    + upload_image(db, id, file): Producto
  }

  class InventarioController <<Controller>> {
    + GET /productos
    + GET /productos/{id}
    + POST /productos
    + PUT /productos/{id}
    + DELETE /productos/{id}
    + POST /productos/{id}/reserve
    + POST /productos/{id}/release
    + POST /productos/{id}/imagen
    + CRUD /tipos, /garantias, /empaques, /descuentos
    + GET-POST /productos/{id}/tallas
    + GET-POST /productos/{id}/resenas
    + GET-POST-DELETE /favoritos
  }
}

' ══════════════════════════════════════════════════════════════
'  Microservicio Pedidos
' ══════════════════════════════════════════════════════════════
package "Microservicio Pedidos" #LightYellow {
  class Pedido <<Entity>> {
    - id: UUID
    - usuario_id: UUID
    - fecha_creacion: DateTime(tz)
    - estado: String(50) = "pendiente"
    - subtotal: Numeric(12,2)
    - shipping: Numeric(12,2)
    - total: Numeric(12,2)
    - direccion_entrega: String(500)
    - coordenadas_entrega: String(100)?
    - created_at: DateTime(tz)
    - updated_at: DateTime(tz)
  }

  class PedidoItem <<Entity>> {
    - id: UUID
    - pedido_id: UUID «FK»
    - producto_id: UUID
    - variante: String(100)?
    - cantidad: Integer
    - precio_unitario: Numeric(12,2)
  }

  class PedidoEvento <<Entity>> {
    - id: UUID
    - pedido_id: UUID «FK»
    - event_id: String(255) «unique»
    - evento: String(100)
    - payload: JSON = {}
    - created_at: DateTime(tz)
  }

  class PedidoService <<Service>> {
    + create_order(db, data): Pedido
    + get_order(db, pedido_id): Pedido
    + list_orders(db, usuario_id?): list[Pedido]
    + update_status(db, pedido_id, status): void
    + process_payment(db, pedido_id, pago): PagoResponse
  }

  class PedidoRepository <<Repository>> {
    + create(db, pedido, items): Pedido
    + get_by_id(db, id): Pedido
    + list_by_user(db, usuario_id?): list[Pedido]
    + update_status(db, id, status): void
    + record_event(db, pedido_id, event_id, evento, payload): void
  }

  class PedidosController <<Controller>> {
    + POST /pedidos
    + GET /pedidos
    + GET /pedidos/{id}
    + PUT /pedidos/{id}/estado
    + POST /pedidos/{id}/pago
  }
}

' ══════════════════════════════════════════════════════════════
'  Microservicio Entregas
' ══════════════════════════════════════════════════════════════
package "Microservicio Entregas" #LightCoral {
  class Entrega <<Entity>> {
    - id: UUID
    - pedido_id: UUID «unique»
    - estado: String(50) = "programada"
    - guia: String(100)?
    - fecha_programada: DateTime(tz)?
    - fecha_entrega: DateTime(tz)?
    - direccion: String(500)
    - notas: Text?
    - created_at: DateTime(tz)
    - updated_at: DateTime(tz)
  }

  class EntregaEvento <<Entity>> {
    - id: UUID
    - entrega_id: UUID «FK»
    - event_id: String(255) «unique»
    - evento: String(100)
    - payload: JSON = {}
    - created_at: DateTime(tz)
  }

  class EntregaService <<Service>> {
    + create_delivery(db, data): Entrega
    + get_delivery(db, id): Entrega
    + get_by_pedido(db, pedido_id): Entrega
    + list_deliveries(db): list[Entrega]
    + update_status(db, id, data): Entrega
    + reschedule(db, id, data): Entrega
  }

  class EntregaRepository <<Repository>> {
    + create(db, entrega): Entrega
    + get_by_id(db, id): Entrega?
    + get_by_pedido_id(db, pedido_id): Entrega?
    + list_all(db): list[Entrega]
    + update_status(db, id, estado, notas?): void
    + reschedule(db, id, fecha): void
    + record_event(db, entrega_id, event_id, evento, payload): void
  }

  class EntregasController <<Controller>> {
    + POST /entregas
    + GET /entregas
    + GET /entregas/{id}
    + PUT /entregas/{id}/estado
    + PUT /entregas/{id}/reagendar
    + GET /entregas/pedido/{pedido_id}
  }
}

' ══════════════════════════════════════════════════════════════
'  Microservicio Campañas
' ══════════════════════════════════════════════════════════════
package "Microservicio Campañas" #Lavender {
  class Campana <<Entity>> {
    - id: UUID
    - titulo: String(255)
    - mensaje_global: Text
    - segmentacion: String(255)?
    - fecha_inicio: DateTime(tz)
    - fecha_fin: DateTime(tz)
    - activa: Boolean = false
    - created_at: DateTime(tz)
    - updated_at: DateTime(tz)
  }

  class Publicacion <<Entity>> {
    - id: UUID
    - campana_id: UUID «FK»
    - tipo_media: String(50)
    - media_url: String(1024)?
    - caption: Text
    - canal: String(100)
    - scheduled_at: DateTime(tz)?
    - publicada: Boolean = false
    - created_at: DateTime(tz)
  }

  class ConfiguracionTienda <<Entity>> {
    - id: UUID
    - logo_url: String(500)?
    - email_contacto / email_soporte: String(255)?
    - telefono_contacto / telefono_soporte: String(50)?
    - envio_gratis_desde: Numeric(10,2)?
    - costo_envio: Numeric(10,2)?
    - instagram_url / tiktok_url: String(500)?
    - whatsapp_url / facebook_url: String(500)?
    - color_primary_h/s/l: Integer
    - color_accent_h/s/l: Integer
    - color_secondary_h/s/l: Integer
    - atenuacion: Integer = 10
    - home/login/register/about_image_url: String(500)?
    - footer_light_text: Boolean = true
    - created_at / updated_at: DateTime(tz)
  }

  class CampanaService <<Service>> {
    + create_campaign(db, data): Campana
    + list_campaigns(db): list[Campana]
    + get_campaign(db, id): Campana
    + update_campaign(db, id, data): Campana
    + activate_campaign(db, id): Campana
    + delete_campaign(db, id): void
  }

  class PublicacionService <<Service>> {
    + create_publication(db, data): Publicacion
    + list_by_campaign(db, campana_id): list[Publicacion]
    + publish(db, pub_id): Publicacion
    + schedule(db, pub_id, scheduled_at): Publicacion
    + delete(db, pub_id): void
  }

  class CampanasController <<Controller>> {
    + POST /campanas
    + GET /campanas
    + GET /campanas/{id}
    + PUT /campanas/{id}
    + POST /campanas/{id}/activar
    + DELETE /campanas/{id}
  }

  class PublicacionesController <<Controller>> {
    + POST /publicaciones
    + GET /publicaciones/campana/{id}
    + POST /publicaciones/{id}/publicar
    + POST /publicaciones/{id}/programar
    + POST /publicaciones/upload
    + DELETE /publicaciones/{id}
  }

  class ConfigTiendaController <<Controller>> {
    + GET /config
    + PUT /config
    + POST /config/logo
    + POST /config/images/{slot}
  }
}

' ══════════════════════════════════════════════════════════════
'  Microservicio n8n-Orchestrator
' ══════════════════════════════════════════════════════════════
package "Microservicio n8n-Orchestrator" #Wheat {
  class WorkflowRegistry <<Entity>> {
    - id: UUID
    - n8n_workflow_id: String(100)? «unique»
    - name: String(255)
    - description: Text?
    - trigger_event: String(100) «indexed»
    - webhook_path: String(500)?
    - active: Boolean = false
    - created_at: DateTime(tz)
    - updated_at: DateTime(tz)
  }

  class NotificationPreference <<Entity>> {
    - id: UUID
    - usuario_id: UUID «indexed»
    - nombre_admin: String(255)
    - canal: String(50)
    - destino: String(255)
    - eventos: JSON = []
    - activo: Boolean = true
    - created_at: DateTime(tz)
    - updated_at: DateTime(tz)
  }

  class N8nClient <<Service>> {
    - base_url: string
    - api_key: string
    - client: httpx.AsyncClient
    + list_workflows(): list
    + get_workflow(id): dict
    + activate_workflow(id): dict
    + deactivate_workflow(id): dict
    + trigger_webhook(path, data): dict
    + list_executions(wf_id?, status?, limit?): list
    + health(): dict
  }

  class WorkflowService <<Service>> {
    + create(db, data): WorkflowRegistry
    + list(db): list[WorkflowRegistry]
    + update(db, id, data): WorkflowRegistry
    + delete(db, id): void
    + trigger_workflow(db, event, payload): list[result]
  }

  class NotificationService <<Service>> {
    + create(db, data): NotificationPreference
    + list(db): list[NotificationPreference]
    + update(db, id, data): NotificationPreference
    + delete(db, id): void
    + dispatch_notification(db, event, payload): void
  }

  class OrchestratorController <<Controller>> {
    + CRUD /workflows
    + POST /workflows/trigger
    + GET  /workflows/n8n/list
    + POST /workflows/n8n/{id}/activate
    + POST /workflows/n8n/{id}/deactivate
    + GET  /workflows/n8n/executions/list
    + CRUD /notifications/preferences
    + POST /notifications/dispatch
  }

  class EventHandlers <<Handler>> {
    + handle_event(event_type, payload): void
    .. despacha a workflows y notificaciones ..
  }
}

' ══════════════════════════════════════════════════════════════
'  n8n (Plataforma de Automatizacion)
' ══════════════════════════════════════════════════════════════
package "n8n (Workflow Automation)" #MistyRose {
  class n8nEngine <<External>> {
    + REST API v1  (gestionada por N8N_API_KEY)
    + Webhook endpoints (triggers)
    + Workflows: notificaciones WhatsApp,
    ..email, stock alerts, publicaciones..
    + DB: postgres-n8n
  }
}

' ══════════════════════════════════════════════════════════════
'  Frontend (Next.js / React)
' ══════════════════════════════════════════════════════════════
package "Frontend (Next.js 14 + React + Tailwind + shadcn/ui)" #AliceBlue {
  class AuthContext <<Context>> {
    + token: string?
    + user: UsuarioResponse?
    + login(email, password): void
    + googleLogin(credential): void
    + logout(): void
  }

  class StoreConfigContext <<Context>> {
    + config: ConfiguracionTiendaResponse?
    + refresh(): void
  }

  class CartState <<State>> {
    + items: CartItem[]
    + addItem(product, qty, variant?): void
    + removeItem(id): void
    + updateQuantity(id, qty): void
    + total: Decimal
  }

  class ApiClient <<Service>> {
    + usersApi: usuarios CRUD
    + inventoryApi: productos, tipos, resenas, favoritos
    + ordersApi: pedidos CRUD + pago
    + deliveriesApi: entregas CRUD
    + campaignsApi: campanas CRUD + activar
    + publicationsApi: publicaciones + upload media
    + orchestratorApi: workflows + notificaciones
    + storeConfigApi: configuracion tienda
    - baseUrl: "/api"
    - authToken: string?
  }

  class Pages <<View>> {
    + HomePage (hero, products, testimonials)
    + ProductsPage (catalogo con filtros)
    + ProductDetailPage [id] (resenas, tallas)
    + CartPage
    + PaymentPage (checkout)
    + OrdersPage (historial)
    + LoginPage / RegisterPage
    + AccountPage (direcciones, metodos pago)
    + DashboardPage (admin: 8 secciones)
  }

  class DashboardSections <<View>> {
    + Resumen (metricas KPI)
    + Pedidos (gestion de pedidos)
    + Productos (CRUD + imagen)
    + Catalogo (tipos, garantias, empaques, descuentos)
    + Clientes (roles, listado)
    + Estadisticas (graficos)
    + Campanas (CampaignsSection)
    + Ajustes (configuracion tienda, colores, logo)
  }
}

' ══════════════════════════════════════════════════════════════
'  Relaciones – Usuarios
' ══════════════════════════════════════════════════════════════
Usuario "1" --> "0..*" Sesion : genera
Usuario "1" --> "0..*" Direccion : tiene
Usuario "1" --> "0..*" MetodoPago : posee
Usuario "1" --> "0..*" Pedido : realiza

UsuariosController --> UsuarioService
UsuarioService --> UsuarioRepository
UsuarioService --> KafkaEventProducer : publica user.registered

' ══════════════════════════════════════════════════════════════
'  Relaciones – Inventario
' ══════════════════════════════════════════════════════════════
Producto "0..*" --> "0..1" TipoProducto
Producto "0..*" --> "0..1" Garantia
Producto "0..*" --> "0..1" Empaque
Producto "0..*" --> "0..1" Descuento
Producto "1" --> "0..*" Resena : tiene
Producto "1" --> "0..*" Talla : define
Producto "1" --> "0..*" Favorito : marcado
Producto "1" --> "0..*" ReglaDisponibilidad : tiene

InventarioController --> InventarioService
InventarioService --> InventarioRepository
InventarioService --> KafkaEventProducer : publica stock.reserved

KafkaEventConsumer --> InventarioService : consume order.created

' ══════════════════════════════════════════════════════════════
'  Relaciones – Pedidos
' ══════════════════════════════════════════════════════════════
Pedido "1" --> "1..*" PedidoItem : contiene
Pedido "1" --> "0..*" PedidoEvento : registra
PedidoItem "0..*" --> "1" Producto : referencia

PedidosController --> PedidoService
PedidoService --> PedidoRepository
PedidoService --> KafkaEventProducer : publica order.created,\npayment.succeeded

' ══════════════════════════════════════════════════════════════
'  Relaciones – Entregas
' ══════════════════════════════════════════════════════════════
Pedido "1" --> "0..1" Entrega : genera
Entrega "1" --> "0..*" EntregaEvento : registra

EntregasController --> EntregaService
EntregaService --> EntregaRepository
EntregaService --> KafkaEventProducer : publica entrega.programada,\nen_transito, entregada, reagendada

KafkaEventConsumer --> EntregaService : consume payment.succeeded

' ══════════════════════════════════════════════════════════════
'  Relaciones – Campanas
' ══════════════════════════════════════════════════════════════
Campana "1" --> "1..*" Publicacion : contiene

CampanasController --> CampanaService
PublicacionesController --> PublicacionService
CampanaService --> KafkaEventProducer : publica campana.activada
PublicacionService --> KafkaEventProducer : publica publicacion.publicada,\npublicacion.programada

' ══════════════════════════════════════════════════════════════
'  Relaciones – n8n-Orchestrator
' ══════════════════════════════════════════════════════════════
OrchestratorController --> WorkflowService
OrchestratorController --> NotificationService
WorkflowService --> N8nClient : proxy y trigger
NotificationService --> N8nClient : dispatch via webhook
EventHandlers --> WorkflowService : trigger workflows
EventHandlers --> NotificationService : notify admins

KafkaEventConsumer --> EventHandlers : consume ALL topics\n(order.created, payment.succeeded,\ninventory, entrega.*, campana.*,\npublicacion.*)

N8nClient --> n8nEngine : REST API v1 + Webhooks

' ══════════════════════════════════════════════════════════════
'  Relaciones – Frontend
' ══════════════════════════════════════════════════════════════
Pages --> ApiClient : consume REST /api/*
Pages --> DashboardSections : admin panel
ApiClient --> UsuariosController : /api/users/
ApiClient --> InventarioController : /api/inventory/
ApiClient --> PedidosController : /api/orders/
ApiClient --> EntregasController : /api/deliveries/
ApiClient --> CampanasController : /api/campaigns/
ApiClient --> PublicacionesController : /api/publications/
ApiClient --> OrchestratorController : /api/orchestrator/
ApiClient --> ConfigTiendaController : /api/campaigns/ (config)

' ══════════════════════════════════════════════════════════════
'  Notas
' ══════════════════════════════════════════════════════════════
note right of Usuario
  Cada microservicio tiene su propia BD PostgreSQL
  y su bucket MinIO para archivos multimedia.
  Comunicacion asincrona via Kafka KRaft.
  gRPC sincrono: Pedidos -> Inventario (reserva)
  y Pedidos -> Entregas (programar).
end note

note bottom of n8nEngine
  n8n gestiona workflows de automatizacion:
  - Notificaciones WhatsApp/Email a admins
  - Alertas de stock bajo
  - Publicacion en redes sociales
  - Procesamiento post-pago
  API Key configurada via N8N_API_KEY env var.
  URL publica configurada via N8N_URL env var.
end note

note bottom of DashboardSections
  Dashboard admin con 8 secciones:
  Resumen - Pedidos - Productos - Catalogo
  Clientes - Estadisticas - Campanas - Ajustes
end note

note left of KafkaEventProducer
  Topics Kafka:
  - order.created
  - payment.succeeded
  - stock.reserved
  - inventory (stock updates)
  - user.registered
  - entrega.programada / en_transito / entregada / reagendada
  - campana.activada
  - publicacion.publicada / programada
end note

@enduml

